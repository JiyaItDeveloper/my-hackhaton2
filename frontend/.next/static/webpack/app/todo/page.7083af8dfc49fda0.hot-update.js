"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/todo/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTodo: () => (/* binding */ createTodo),\n/* harmony export */   deleteTodo: () => (/* binding */ deleteTodo),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   getTodoById: () => (/* binding */ getTodoById),\n/* harmony export */   getUserTodos: () => (/* binding */ getUserTodos),\n/* harmony export */   loginUser: () => (/* binding */ loginUser),\n/* harmony export */   logoutUser: () => (/* binding */ logoutUser),\n/* harmony export */   registerUser: () => (/* binding */ registerUser),\n/* harmony export */   toggleTodo: () => (/* binding */ toggleTodo),\n/* harmony export */   updateTodo: () => (/* binding */ updateTodo)\n/* harmony export */ });\nconst API_BASE_URL = \"http://localhost:8000/api\" || 0;\n// Helper function to get the auth token from localStorage\nconst getAuthToken = ()=>{\n    if (true) {\n        return localStorage.getItem('auth_token');\n    }\n    return null;\n};\n// Helper function to make authenticated API requests with token refresh capability\nconst apiRequest = async function(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    let token = getAuthToken();\n    const headers = {\n        'Content-Type': 'application/json',\n        'ngrok-skip-browser-warning': 'true',\n        ...token && {\n            'Authorization': \"Bearer \".concat(token)\n        },\n        ...options.headers\n    };\n    try {\n        let response = await fetch(\"\".concat(API_BASE_URL).concat(endpoint), {\n            ...options,\n            headers\n        });\n        // If we get a 401 Unauthorized error, try to refresh the token or clear session\n        if (response.status === 401) {\n            // Clear the invalid token\n            if (true) {\n                localStorage.removeItem('auth_token');\n            }\n            // Throw a specific error for unauthorized access\n            throw new Error('Session expired. Please sign in again.');\n        }\n        if (!response.ok) {\n            // Handle error response - could be JSON or plain text\n            let errorData;\n            const contentType = response.headers.get('content-type');\n            if (contentType && contentType.includes('application/json')) {\n                errorData = await response.json().catch(()=>({\n                        message: \"HTTP error! status: \".concat(response.status)\n                    }));\n            } else {\n                const errorText = await response.text().catch(()=>\"HTTP error! status: \".concat(response.status));\n                errorData = {\n                    message: errorText\n                };\n            }\n            throw new Error(errorData.message || \"HTTP error! status: \".concat(response.status));\n        }\n        return response.json();\n    } catch (error) {\n        if (error instanceof TypeError && error.message.includes('fetch')) {\n            // Network error\n            throw new Error('Failed to connect to server. Please check your connection and try again.');\n        }\n        throw error;\n    }\n};\n// AUTHENTICATION API\nconst registerUser = async (userData)=>{\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/auth/register\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(userData)\n        });\n        if (!response.ok) {\n            // Handle error response - could be JSON or plain text\n            let errorData;\n            const contentType = response.headers.get('content-type');\n            if (contentType && contentType.includes('application/json')) {\n                errorData = await response.json().catch(()=>({\n                        detail: \"HTTP error! status: \".concat(response.status)\n                    }));\n            } else {\n                const errorText = await response.text().catch(()=>\"HTTP error! status: \".concat(response.status));\n                errorData = {\n                    detail: errorText\n                };\n            }\n            throw new Error(errorData.detail || 'Registration failed');\n        }\n        return response.json();\n    } catch (error) {\n        if (error instanceof TypeError && error.message.includes('fetch')) {\n            // Network error\n            throw new Error('Failed to connect to server. Please check your connection and try again.');\n        }\n        throw error;\n    }\n};\nconst loginUser = async (credentials)=>{\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/auth/login\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(credentials)\n        });\n        if (!response.ok) {\n            // Handle error response - could be JSON or plain text\n            let errorData;\n            const contentType = response.headers.get('content-type');\n            if (contentType && contentType.includes('application/json')) {\n                errorData = await response.json().catch(()=>({\n                        detail: \"HTTP error! status: \".concat(response.status)\n                    }));\n            } else {\n                const errorText = await response.text().catch(()=>\"HTTP error! status: \".concat(response.status));\n                errorData = {\n                    detail: errorText\n                };\n            }\n            throw new Error(errorData.detail || 'Login failed');\n        }\n        return response.json();\n    } catch (error) {\n        if (error instanceof TypeError && error.message.includes('fetch')) {\n            // Network error\n            throw new Error('Failed to connect to server. Please check your connection and try again.');\n        }\n        throw error;\n    }\n};\nconst getCurrentUser = async ()=>{\n    return apiRequest('/auth/me');\n};\nconst logoutUser = async ()=>{\n    const token = getAuthToken();\n    if (token) {\n        try {\n            // Call backend logout endpoint to invalidate the token\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/auth/logout\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(token)\n                }\n            });\n            // We don't necessarily need to check the response for logout, but log any errors\n            if (!response.ok) {\n                const contentType = response.headers.get('content-type');\n                let errorText = \"HTTP error! status: \".concat(response.status);\n                if (contentType && contentType.includes('application/json')) {\n                    const errorData = await response.json().catch(()=>({\n                            message: errorText\n                        }));\n                    errorText = errorData.message || errorText;\n                } else {\n                    errorText = await response.text().catch(()=>errorText);\n                }\n                console.warn('Backend logout error:', errorText);\n            }\n        } catch (error) {\n            // Even if backend logout fails, still clear local storage\n            console.warn('Backend logout failed, clearing local session', error);\n        }\n    }\n    // Always clear the local token\n    if (true) {\n        localStorage.removeItem('auth_token');\n    }\n};\n// TODO API\nconst getUserTodos = async ()=>{\n    return apiRequest('/tasks');\n};\nconst createTodo = async (todoData)=>{\n    return apiRequest('/tasks', {\n        method: 'POST',\n        body: JSON.stringify(todoData)\n    });\n};\nconst getTodoById = async (id)=>{\n    return apiRequest(\"/tasks/\".concat(id));\n};\nconst deleteTodo = async (id)=>{\n    await apiRequest(\"/tasks/\".concat(id), {\n        method: 'DELETE'\n    });\n};\nconst toggleTodo = async (id)=>{\n    return apiRequest(\"/tasks/\".concat(id, \"/complete\"), {\n        method: 'PATCH'\n    });\n};\nconst updateTodo = async (id, todoData)=>{\n    return apiRequest(\"/tasks/\".concat(id), {\n        method: 'PUT',\n        body: JSON.stringify(todoData)\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVBLE1BQU1BLGVBQWVDLDJCQUErQixJQUFJLENBQTJCO0FBRW5GLDBEQUEwRDtBQUMxRCxNQUFNRyxlQUFlO0lBQ25CLElBQUksSUFBNkIsRUFBRTtRQUNqQyxPQUFPQyxhQUFhQyxPQUFPLENBQUM7SUFDOUI7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxtRkFBbUY7QUFDbkYsTUFBTUMsYUFBYSxlQUFPQztRQUFrQkMsMkVBQXVCLENBQUM7SUFDbEUsSUFBSUMsUUFBUU47SUFFWixNQUFNTyxVQUFVO1FBQ2QsZ0JBQWdCO1FBQ2hCLDhCQUE4QjtRQUM5QixHQUFJRCxTQUFTO1lBQUUsaUJBQWlCLFVBQWdCLE9BQU5BO1FBQVEsQ0FBQztRQUNuRCxHQUFHRCxRQUFRRSxPQUFPO0lBQ3BCO0lBRUEsSUFBSTtRQUNGLElBQUlDLFdBQVcsTUFBTUMsTUFBTSxHQUFrQkwsT0FBZlIsY0FBd0IsT0FBVFEsV0FBWTtZQUN2RCxHQUFHQyxPQUFPO1lBQ1ZFO1FBQ0Y7UUFFQSxnRkFBZ0Y7UUFDaEYsSUFBSUMsU0FBU0UsTUFBTSxLQUFLLEtBQUs7WUFDM0IsMEJBQTBCO1lBQzFCLElBQUksSUFBNkIsRUFBRTtnQkFDakNULGFBQWFVLFVBQVUsQ0FBQztZQUMxQjtZQUVBLGlEQUFpRDtZQUNqRCxNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxJQUFJLENBQUNKLFNBQVNLLEVBQUUsRUFBRTtZQUNoQixzREFBc0Q7WUFDdEQsSUFBSUM7WUFDSixNQUFNQyxjQUFjUCxTQUFTRCxPQUFPLENBQUNTLEdBQUcsQ0FBQztZQUV6QyxJQUFJRCxlQUFlQSxZQUFZRSxRQUFRLENBQUMscUJBQXFCO2dCQUMzREgsWUFBWSxNQUFNTixTQUFTVSxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPO3dCQUFFQyxTQUFTLHVCQUF1QyxPQUFoQlosU0FBU0UsTUFBTTtvQkFBRztZQUNyRyxPQUFPO2dCQUNMLE1BQU1XLFlBQVksTUFBTWIsU0FBU2MsSUFBSSxHQUFHSCxLQUFLLENBQUMsSUFBTSx1QkFBdUMsT0FBaEJYLFNBQVNFLE1BQU07Z0JBQzFGSSxZQUFZO29CQUFFTSxTQUFTQztnQkFBVTtZQUNuQztZQUVBLE1BQU0sSUFBSVQsTUFBTUUsVUFBVU0sT0FBTyxJQUFJLHVCQUF1QyxPQUFoQlosU0FBU0UsTUFBTTtRQUM3RTtRQUVBLE9BQU9GLFNBQVNVLElBQUk7SUFDdEIsRUFBRSxPQUFPSyxPQUFPO1FBQ2QsSUFBSUEsaUJBQWlCQyxhQUFhRCxNQUFNSCxPQUFPLENBQUNILFFBQVEsQ0FBQyxVQUFVO1lBQ2pFLGdCQUFnQjtZQUNoQixNQUFNLElBQUlMLE1BQU07UUFDbEI7UUFDQSxNQUFNVztJQUNSO0FBQ0Y7QUFFQSxxQkFBcUI7QUFDZCxNQUFNRSxlQUFlLE9BQU9DO0lBQ2pDLElBQUk7UUFDRixNQUFNbEIsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJiLGNBQWEsbUJBQWlCO1lBQzVEK0IsUUFBUTtZQUNScEIsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDOUNxQixNQUFNQyxLQUFLQyxTQUFTLENBQUNKO1FBQ3ZCO1FBRUEsSUFBSSxDQUFDbEIsU0FBU0ssRUFBRSxFQUFFO1lBQ2hCLHNEQUFzRDtZQUN0RCxJQUFJQztZQUNKLE1BQU1DLGNBQWNQLFNBQVNELE9BQU8sQ0FBQ1MsR0FBRyxDQUFDO1lBRXpDLElBQUlELGVBQWVBLFlBQVlFLFFBQVEsQ0FBQyxxQkFBcUI7Z0JBQzNESCxZQUFZLE1BQU1OLFNBQVNVLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU87d0JBQUVZLFFBQVEsdUJBQXVDLE9BQWhCdkIsU0FBU0UsTUFBTTtvQkFBRztZQUNwRyxPQUFPO2dCQUNMLE1BQU1XLFlBQVksTUFBTWIsU0FBU2MsSUFBSSxHQUFHSCxLQUFLLENBQUMsSUFBTSx1QkFBdUMsT0FBaEJYLFNBQVNFLE1BQU07Z0JBQzFGSSxZQUFZO29CQUFFaUIsUUFBUVY7Z0JBQVU7WUFDbEM7WUFFQSxNQUFNLElBQUlULE1BQU1FLFVBQVVpQixNQUFNLElBQUk7UUFDdEM7UUFFQSxPQUFPdkIsU0FBU1UsSUFBSTtJQUN0QixFQUFFLE9BQU9LLE9BQU87UUFDZCxJQUFJQSxpQkFBaUJDLGFBQWFELE1BQU1ILE9BQU8sQ0FBQ0gsUUFBUSxDQUFDLFVBQVU7WUFDakUsZ0JBQWdCO1lBQ2hCLE1BQU0sSUFBSUwsTUFBTTtRQUNsQjtRQUNBLE1BQU1XO0lBQ1I7QUFDRixFQUFFO0FBRUssTUFBTVMsWUFBWSxPQUFPQztJQUM5QixJQUFJO1FBQ0YsTUFBTXpCLFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFiYixjQUFhLGdCQUFjO1lBQ3pEK0IsUUFBUTtZQUNScEIsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDOUNxQixNQUFNQyxLQUFLQyxTQUFTLENBQUNHO1FBQ3ZCO1FBRUEsSUFBSSxDQUFDekIsU0FBU0ssRUFBRSxFQUFFO1lBQ2hCLHNEQUFzRDtZQUN0RCxJQUFJQztZQUNKLE1BQU1DLGNBQWNQLFNBQVNELE9BQU8sQ0FBQ1MsR0FBRyxDQUFDO1lBRXpDLElBQUlELGVBQWVBLFlBQVlFLFFBQVEsQ0FBQyxxQkFBcUI7Z0JBQzNESCxZQUFZLE1BQU1OLFNBQVNVLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU87d0JBQUVZLFFBQVEsdUJBQXVDLE9BQWhCdkIsU0FBU0UsTUFBTTtvQkFBRztZQUNwRyxPQUFPO2dCQUNMLE1BQU1XLFlBQVksTUFBTWIsU0FBU2MsSUFBSSxHQUFHSCxLQUFLLENBQUMsSUFBTSx1QkFBdUMsT0FBaEJYLFNBQVNFLE1BQU07Z0JBQzFGSSxZQUFZO29CQUFFaUIsUUFBUVY7Z0JBQVU7WUFDbEM7WUFFQSxNQUFNLElBQUlULE1BQU1FLFVBQVVpQixNQUFNLElBQUk7UUFDdEM7UUFFQSxPQUFPdkIsU0FBU1UsSUFBSTtJQUN0QixFQUFFLE9BQU9LLE9BQU87UUFDZCxJQUFJQSxpQkFBaUJDLGFBQWFELE1BQU1ILE9BQU8sQ0FBQ0gsUUFBUSxDQUFDLFVBQVU7WUFDakUsZ0JBQWdCO1lBQ2hCLE1BQU0sSUFBSUwsTUFBTTtRQUNsQjtRQUNBLE1BQU1XO0lBQ1I7QUFDRixFQUFFO0FBRUssTUFBTVcsaUJBQWlCO0lBQzVCLE9BQU8vQixXQUFXO0FBQ3BCLEVBQUU7QUFFSyxNQUFNZ0MsYUFBYTtJQUN4QixNQUFNN0IsUUFBUU47SUFFZCxJQUFJTSxPQUFPO1FBQ1QsSUFBSTtZQUNGLHVEQUF1RDtZQUN2RCxNQUFNRSxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYmIsY0FBYSxpQkFBZTtnQkFDMUQrQixRQUFRO2dCQUNScEIsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLGlCQUFpQixVQUFnQixPQUFORDtnQkFDN0I7WUFDRjtZQUVBLGlGQUFpRjtZQUNqRixJQUFJLENBQUNFLFNBQVNLLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUUsY0FBY1AsU0FBU0QsT0FBTyxDQUFDUyxHQUFHLENBQUM7Z0JBQ3pDLElBQUlLLFlBQVksdUJBQXVDLE9BQWhCYixTQUFTRSxNQUFNO2dCQUV0RCxJQUFJSyxlQUFlQSxZQUFZRSxRQUFRLENBQUMscUJBQXFCO29CQUMzRCxNQUFNSCxZQUFZLE1BQU1OLFNBQVNVLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU87NEJBQUVDLFNBQVNDO3dCQUFVO29CQUMxRUEsWUFBWVAsVUFBVU0sT0FBTyxJQUFJQztnQkFDbkMsT0FBTztvQkFDTEEsWUFBWSxNQUFNYixTQUFTYyxJQUFJLEdBQUdILEtBQUssQ0FBQyxJQUFNRTtnQkFDaEQ7Z0JBRUFlLFFBQVFDLElBQUksQ0FBQyx5QkFBeUJoQjtZQUN4QztRQUNGLEVBQUUsT0FBT0UsT0FBTztZQUNkLDBEQUEwRDtZQUMxRGEsUUFBUUMsSUFBSSxDQUFDLGlEQUFpRGQ7UUFDaEU7SUFDRjtJQUVBLCtCQUErQjtJQUMvQixJQUFJLElBQTZCLEVBQUU7UUFDakN0QixhQUFhVSxVQUFVLENBQUM7SUFDMUI7QUFDRixFQUFFO0FBRUYsV0FBVztBQUNKLE1BQU0yQixlQUFlO0lBQzFCLE9BQU9uQyxXQUFXO0FBQ3BCLEVBQUU7QUFFSyxNQUFNb0MsYUFBYSxPQUFPQztJQUMvQixPQUFPckMsV0FBVyxVQUFVO1FBQzFCd0IsUUFBUTtRQUNSQyxNQUFNQyxLQUFLQyxTQUFTLENBQUNVO0lBQ3ZCO0FBQ0YsRUFBRTtBQUVLLE1BQU1DLGNBQWMsT0FBT0M7SUFDaEMsT0FBT3ZDLFdBQVcsVUFBYSxPQUFIdUM7QUFDOUIsRUFBRTtBQUVLLE1BQU1DLGFBQWEsT0FBT0Q7SUFDL0IsTUFBTXZDLFdBQVcsVUFBYSxPQUFIdUMsS0FBTTtRQUMvQmYsUUFBUTtJQUNWO0FBQ0YsRUFBRTtBQUVLLE1BQU1pQixhQUFhLE9BQU9GO0lBQy9CLE9BQU92QyxXQUFXLFVBQWEsT0FBSHVDLElBQUcsY0FBWTtRQUN6Q2YsUUFBUTtJQUNWO0FBQ0YsRUFBRTtBQUVLLE1BQU1rQixhQUFhLE9BQU9ILElBQVlGO0lBQzNDLE9BQU9yQyxXQUFXLFVBQWEsT0FBSHVDLEtBQU07UUFDaENmLFFBQVE7UUFDUkMsTUFBTUMsS0FBS0MsU0FBUyxDQUFDVTtJQUN2QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVU5JLVRFQ0hcXERlc2t0b3BcXEhhY2thdG9uMi1waGFzZTJcXGZyb250ZW5kXFxsaWJcXGFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVc2VyLCBUb2RvLCBUb2RvQ3JlYXRlLCBUb2RvVXBkYXRlIH0gZnJvbSAnQC90eXBlcy90b2RvJztcblxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaSc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGF1dGggdG9rZW4gZnJvbSBsb2NhbFN0b3JhZ2VcbmNvbnN0IGdldEF1dGhUb2tlbiA9ICgpOiBzdHJpbmcgfCBudWxsID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoX3Rva2VuJyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gbWFrZSBhdXRoZW50aWNhdGVkIEFQSSByZXF1ZXN0cyB3aXRoIHRva2VuIHJlZnJlc2ggY2FwYWJpbGl0eVxuY29uc3QgYXBpUmVxdWVzdCA9IGFzeW5jIChlbmRwb2ludDogc3RyaW5nLCBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9KSA9PiB7XG4gIGxldCB0b2tlbiA9IGdldEF1dGhUb2tlbigpO1xuXG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAnbmdyb2stc2tpcC1icm93c2VyLXdhcm5pbmcnOiAndHJ1ZScsXG4gICAgLi4uKHRva2VuICYmIHsgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCB9KSxcbiAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9JHtlbmRwb2ludH1gLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcblxuICAgIC8vIElmIHdlIGdldCBhIDQwMSBVbmF1dGhvcml6ZWQgZXJyb3IsIHRyeSB0byByZWZyZXNoIHRoZSB0b2tlbiBvciBjbGVhciBzZXNzaW9uXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAvLyBDbGVhciB0aGUgaW52YWxpZCB0b2tlblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoX3Rva2VuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRocm93IGEgc3BlY2lmaWMgZXJyb3IgZm9yIHVuYXV0aG9yaXplZCBhY2Nlc3NcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBleHBpcmVkLiBQbGVhc2Ugc2lnbiBpbiBhZ2Fpbi4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAvLyBIYW5kbGUgZXJyb3IgcmVzcG9uc2UgLSBjb3VsZCBiZSBKU09OIG9yIHBsYWluIHRleHRcbiAgICAgIGxldCBlcnJvckRhdGE7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcblxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IG1lc3NhZ2U6IGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IGVycm9yVGV4dCB9O1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZmV0Y2gnKSkge1xuICAgICAgLy8gTmV0d29yayBlcnJvclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCB0byBzZXJ2ZXIuIFBsZWFzZSBjaGVjayB5b3VyIGNvbm5lY3Rpb24gYW5kIHRyeSBhZ2Fpbi4nKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIEFVVEhFTlRJQ0FUSU9OIEFQSVxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyVXNlciA9IGFzeW5jICh1c2VyRGF0YTogeyBlbWFpbDogc3RyaW5nOyBwYXNzd29yZDogc3RyaW5nOyBuYW1lPzogc3RyaW5nIH0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXV0aC9yZWdpc3RlcmAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAvLyBIYW5kbGUgZXJyb3IgcmVzcG9uc2UgLSBjb3VsZCBiZSBKU09OIG9yIHBsYWluIHRleHRcbiAgICAgIGxldCBlcnJvckRhdGE7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcblxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IGRldGFpbDogYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIGVycm9yRGF0YSA9IHsgZGV0YWlsOiBlcnJvclRleHQgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ1JlZ2lzdHJhdGlvbiBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdmZXRjaCcpKSB7XG4gICAgICAvLyBOZXR3b3JrIGVycm9yXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IHRvIHNlcnZlci4gUGxlYXNlIGNoZWNrIHlvdXIgY29ubmVjdGlvbiBhbmQgdHJ5IGFnYWluLicpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGxvZ2luVXNlciA9IGFzeW5jIChjcmVkZW50aWFsczogeyBlbWFpbDogc3RyaW5nOyBwYXNzd29yZDogc3RyaW5nIH0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXV0aC9sb2dpbmAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShjcmVkZW50aWFscyksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAvLyBIYW5kbGUgZXJyb3IgcmVzcG9uc2UgLSBjb3VsZCBiZSBKU09OIG9yIHBsYWluIHRleHRcbiAgICAgIGxldCBlcnJvckRhdGE7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcblxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IGRldGFpbDogYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIGVycm9yRGF0YSA9IHsgZGV0YWlsOiBlcnJvclRleHQgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0xvZ2luIGZhaWxlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2ZldGNoJykpIHtcbiAgICAgIC8vIE5ldHdvcmsgZXJyb3JcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbm5lY3QgdG8gc2VydmVyLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uIGFuZCB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFVzZXIgPSBhc3luYyAoKTogUHJvbWlzZTxVc2VyPiA9PiB7XG4gIHJldHVybiBhcGlSZXF1ZXN0KCcvYXV0aC9tZScpO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvZ291dFVzZXIgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHRva2VuID0gZ2V0QXV0aFRva2VuKCk7XG5cbiAgaWYgKHRva2VuKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENhbGwgYmFja2VuZCBsb2dvdXQgZW5kcG9pbnQgdG8gaW52YWxpZGF0ZSB0aGUgdG9rZW5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hdXRoL2xvZ291dGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFdlIGRvbid0IG5lY2Vzc2FyaWx5IG5lZWQgdG8gY2hlY2sgdGhlIHJlc3BvbnNlIGZvciBsb2dvdXQsIGJ1dCBsb2cgYW55IGVycm9yc1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgbGV0IGVycm9yVGV4dCA9IGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWA7XG5cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgbWVzc2FnZTogZXJyb3JUZXh0IH0pKTtcbiAgICAgICAgICBlcnJvclRleHQgPSBlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvclRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IGVycm9yVGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLndhcm4oJ0JhY2tlbmQgbG9nb3V0IGVycm9yOicsIGVycm9yVGV4dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEV2ZW4gaWYgYmFja2VuZCBsb2dvdXQgZmFpbHMsIHN0aWxsIGNsZWFyIGxvY2FsIHN0b3JhZ2VcbiAgICAgIGNvbnNvbGUud2FybignQmFja2VuZCBsb2dvdXQgZmFpbGVkLCBjbGVhcmluZyBsb2NhbCBzZXNzaW9uJywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFsd2F5cyBjbGVhciB0aGUgbG9jYWwgdG9rZW5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGhfdG9rZW4nKTtcbiAgfVxufTtcblxuLy8gVE9ETyBBUElcbmV4cG9ydCBjb25zdCBnZXRVc2VyVG9kb3MgPSBhc3luYyAoKTogUHJvbWlzZTxUb2RvW10+ID0+IHtcbiAgcmV0dXJuIGFwaVJlcXVlc3QoJy90YXNrcycpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRvZG8gPSBhc3luYyAodG9kb0RhdGE6IFRvZG9DcmVhdGUpOiBQcm9taXNlPFRvZG8+ID0+IHtcbiAgcmV0dXJuIGFwaVJlcXVlc3QoJy90YXNrcycsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0b2RvRGF0YSksXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFRvZG9CeUlkID0gYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPFRvZG8+ID0+IHtcbiAgcmV0dXJuIGFwaVJlcXVlc3QoYC90YXNrcy8ke2lkfWApO1xufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVRvZG8gPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhd2FpdCBhcGlSZXF1ZXN0KGAvdGFza3MvJHtpZH1gLCB7XG4gICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgdG9nZ2xlVG9kbyA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxUb2RvPiA9PiB7XG4gIHJldHVybiBhcGlSZXF1ZXN0KGAvdGFza3MvJHtpZH0vY29tcGxldGVgLCB7XG4gICAgbWV0aG9kOiAnUEFUQ0gnLFxuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVUb2RvID0gYXN5bmMgKGlkOiBzdHJpbmcsIHRvZG9EYXRhOiBUb2RvVXBkYXRlKTogUHJvbWlzZTxUb2RvPiA9PiB7XG4gIHJldHVybiBhcGlSZXF1ZXN0KGAvdGFza3MvJHtpZH1gLCB7XG4gICAgbWV0aG9kOiAnUFVUJyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0b2RvRGF0YSksXG4gIH0pO1xufTsiXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJnZXRBdXRoVG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiYXBpUmVxdWVzdCIsImVuZHBvaW50Iiwib3B0aW9ucyIsInRva2VuIiwiaGVhZGVycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJzdGF0dXMiLCJyZW1vdmVJdGVtIiwiRXJyb3IiLCJvayIsImVycm9yRGF0YSIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiaW5jbHVkZXMiLCJqc29uIiwiY2F0Y2giLCJtZXNzYWdlIiwiZXJyb3JUZXh0IiwidGV4dCIsImVycm9yIiwiVHlwZUVycm9yIiwicmVnaXN0ZXJVc2VyIiwidXNlckRhdGEiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRldGFpbCIsImxvZ2luVXNlciIsImNyZWRlbnRpYWxzIiwiZ2V0Q3VycmVudFVzZXIiLCJsb2dvdXRVc2VyIiwiY29uc29sZSIsIndhcm4iLCJnZXRVc2VyVG9kb3MiLCJjcmVhdGVUb2RvIiwidG9kb0RhdGEiLCJnZXRUb2RvQnlJZCIsImlkIiwiZGVsZXRlVG9kbyIsInRvZ2dsZVRvZG8iLCJ1cGRhdGVUb2RvIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});